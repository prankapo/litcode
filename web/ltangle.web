\subsection{ltangle.py}

Much of the heavy-lifting of collecting all chunks and putting them in a dictionary + putting some metadata
for debugging purposes had already been done \tt ldump\rm. We now have to write \tt ltangle.py \rm which
will just need to expand a chunk/reference which has been passed to it as a command line argument. Let's make
a list of thing which will be passed to \tt ltangle \rm as command line arguments, along with relevant
switches. 

\begin{enumerate}
    \item \tt -i dump/file.json\rm: \tt ltangle \rm will be using the dump file generated by \tt ldump \rm to
    read chunks and expand them recursively.
    \item \tt -R name/of/the/chunk\rm: The name of the chunk we want to expand. 
    \item \tt -cc comment/line/starting/character\rm: Character which is to be appended before metadata lines
    so as to comment them out in the tangled source code. For example, \verb|//| would be used for commenting
    lines in a C or C++ code. If no comment-char is provided, no metadata line will be included.
    \item \tt -ut number/of/spaces/to/convert\rm: Convert specified number of spaces to tabs. Particularly
    useful for systems which accept only tabs (or spaces) for indentation, example: Makefile.
    \item \tt -us number/of/tabs/to/convert\rm: Convert tabs to specified number of spaces.
\end{enumerate}

Like before, we begin our code with a shebang. We import the same modules as before. 

<<ltangle.py>>=
import os
import sys
import re
import json

def version():
    version = '''
    <<version>>
    '''
    print('This is lweave, Version ' + version.strip('\n'))
@

I am setting \tt chunkDict \rm as a global variable. This eliminates the need to pass it as an argument during
recursive expansion of the reference.

<<ltangle.py>>=
chunkDict = dict()

@

\tt expandref \rm is the queen of this program. It takes in a single parameter --- the name of the reference
which is to be expanded recursively.

<<ltangle.py>>=
def expandref(reference):
    <<ltangle: expandref>>

@

Like before, our entry point will be the \tt main \rm function where we will perform much of the processing of
the command-line arguments.

<<ltangle.py>>=
def main():
    <<ltangle: main>>

@

So, this would be the core structure of \tt ltangle\rm. Let's start writing <<ltangle: expandref>> as that is
the most important part of this program. The expanded reference will be kept in \tt codeLines \rm which will
be returned to \tt main \rm for further processing.

<<ltangle: expandref>>=
global chunkDict
codeLines = []
<<Expand the reference>>
return codeLines
@

When expanding reference, we need to take care of the indentation of the reference. This is especially
important when we are dealing with a language where indentation defines a block of code, like in Python. The
pseudo-code for <<Expand the reference>> will be something like this:

\begin{algorithm}
Read a line\\
Check if it contains a reference. \linebreak
\textbf{if} it contains one, call yourself (\texttt{expandref()}) again and expand
upon this reference. Once you get the lines making up this reference, to each line append the whitespace with
which this reference was indented. Then append it to \tt codeLines.\rm\linebreak
\textbf{else} simply append the line to \tt codeLines\rm.

\caption{Pseudocode for \texttt{ltangle.py}}
\label{algo:ltangle-working}
\end{algorithm}

I will be using two variables, \tt encounteredReference \rm and \texttt{indentation} to store the current
state of the function before possible recurrsive call.

<<Expand the reference>>=
encounteredReference = False
indentation = ''
@

I pass the name of the reference to \texttt{chunkDict} and in return I get a list of lines making up that
reference. I iterate over them. At each iteration I check whether the line contains a reference or not. If it
doesn't, I simply append it to \texttt{chunkDict} and move ahead with the next iteration. If it does, then as
per \ref{algo:ltangle-working}, I am going to call \tt expandref\rm with this reference and get its expansion.
This will be stored in \tt buffer\rm.

<<Expand the reference>>=
for line in chunkDict[reference]:
    encounteredReference = re.findall(r'(?<=^<<).+?(?=>>\s*$)', line.strip())
    if encounteredReference:
        reference = encounteredReference[0]
        encounteredReference = True
        buffer = expandref(reference)
@

Now, I extract the whitespace using which we had expanded the reference and append it to each and every line
in the \tt buffer\rm.

<<Expand the reference>>=
        indentation = line[:len(line) - len(line.lstrip())]
        for l in buffer:
            line = indentation + l
            codeLines.append(line)
@

Under the event no reference has been encountered, I simply append the line to \tt codeLines\rm and carry on
with the next iteration.

<<Expand the reference>>=
    else:
        codeLines.append(line)
@

Coming to \tt main\rm, I need to do some processing of command-line arguments to understand how the tangled
code has to be formatted.

<<ltangle: main>>=
global chunkDict
dumpfile = str()
reference = str()
commentchar = None
usetabs = False
whitespace_conv_num = 4
if '-v' in sys.argv or '--version' in sys.argv:
    version()
    exit(0)
if '-i' in sys.argv:
    i = sys.argv.index('-i')
    dumpfile = sys.argv[i + 1]
else:
    print('Cannot find -i flag')
    exit(1)
if '-R' in sys.argv:
    i = sys.argv.index('-R')
    reference = sys.argv[i + 1]
else:
    print('Cannot find -R flag')
    exit(1)
if '-cc' in sys.argv:
    i = sys.argv.index('-cc')
    commentchar = sys.argv[i + 1]
if '-ut' in sys.argv:
    usetabs = True
    i = sys.argv.index('-ut')
    whitespace_conv_num = int(sys.argv[i + 1])
if '-us' in sys.argv:
    usetabs = False
    i = sys.argv.index('-us')
    whitespace_conv_num = int(sys.argv[i + 1])

@

If all is good with the arguments that have been passed to us, we are then going to load the dump file, set
\tt chunkDict\rm and then call \tt expandref \rm passing reference as an argument to it.

<<ltangle: main>>=
# This is the portion where we can load the JSON file
chunkDict = dict()
with open(dumpfile, 'r') as fp:
    chunkDict = json.load(fp)

# Now we call the expandref function
codeLines = expandref(reference)
#print(''.join(codeLines))

@

Now, we have to format the lines --- perform some white-space conversion and comment out metadata lines.

<<ltangle: main>>=
# Now replace '@->' with comment character
lines = []
for line in codeLines:
    <<Perform whitespace conversion>>
    <<Comment out metadata lines>>
    lines.append(line)
codeLines = lines

@

Let us say the line was originally indented by $s$ spaces, which we wish to replace by $t$ tabs and $u$
spaces, with each tab being equivalent to $n_s$ spaces, then we have to implement the following equations: 

$$t = \left\lfloor \frac{s}{n_s} \right\rfloor$$
$$u = s\ \mathbf{mod}\ n_s$$

<<Perform whitespace conversion>>=
# Spaces to Tabs
if usetabs is True:
    indentation_depth = len(line) - len(line.lstrip(' '))
    # This condition is required, otherwise for indentation_depth = 0, all
    # indentation will be eaten away.
    if indentation_depth:
        new_indentation = '\t' * (indentation_depth // whitespace_conv_num)
        new_indentation += ' ' * (indentation_depth % whitespace_conv_num)
        line = new_indentation + line.lstrip()
# Tabs to Spaces
elif usetabs is False:
    indentation_depth = len(line) - len(line.lstrip('\t'))
    if indentation_depth:
        new_indentation = ' ' * (indentation_depth * whitespace_conv_num)
        line = new_indentation + line.lstrip()
@

Commenting metadata lines is pretty simple. Just check if the line starts with \verb|@->| character. If it
does, replace it with \tt commentchar\rm  if it has been supplied in the command line, else just skip it.

<<Comment out metadata lines>>=
if line.lstrip().startswith('@->'):
    if commentchar is not None:
        line = line.replace('@->', commentchar, 1)
    else:
        continue

@

Finally, we are going to print \tt codeLines\rm. The output can be redirected to write to a file using \tt >
\rm operator.

<<ltangle: main>>=
# Now print it
print(''.join(codeLines))

@
